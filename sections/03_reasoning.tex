\section{Rules and Reasoning}
\label{sec:reasoning}
In this section we briefly review concepts of logic programming (see \cite{DBLP:conf/rweb/EiterIK09} for more details) and relational association rules \cite{warmer}.

\subsection{Logic Programs} Logic programs consist of a set of rules. Intuitively, a rule is an if-then expression, whose if-part may contain several conditions, some possibly with
negation. The then-part has a single atom that has to hold, whenever the if-part holds. In general, the left part of a rule can also contain disjunctions, but in this tutorial we consider only non-disjunctive rules. More formally,


% Logic rules have been introduced and used in the context of declarative programming. A set of rules are called logical program. There are several types of logical programs (as explained in~\cite{DBLP:books/sp/Lloyd87}), in this tutorial, we are interested in \textit{Horn} and \textit{Nonmonotonic} Logic Programs.

%We define a logic programs similar to~\cite{DBLP:books/sp/Lloyd87}. 
% Similar to ~\cite{DBLP:books/sp/Lloyd87}, we define a \emph{(nonmonotonic) logic program} $P$ is a set of \emph{rules} of the form

\begin{definition}[Rule] A \emph{rule} $r$ is an expression of the form
\begin{equation}
H\leftarrow B, \naf\ E
\end{equation}
where $H$ is a standard first-order atom of the form $a(\vec{X})$, $B$ is a conjunction of positive atoms of the form $b_1(\vec{Y_1}),\dotsc,b_k(\vec{Y_k})$, and $\naf\ E$ %with slight abuse of notation, 
 is a conjunction of negated atoms $\naf\, b_{k+1}(\vec{Y_{k+1}}),\dotsc,\naf\, b_n(\vec{Y_{n}})$. Moreover,  $\vec{X},\vec{Y_1},\ldots,\vec{Y_{n}}$ are tuples of either constants or variables whose length corresponds to the arity of the predicates $a,b_1,\ldots,b_n$ respectively.
% . such that $\naf$ is the so-called \emph{negation as failure (NAF)} or \emph{default negation}, \ie $\naf\, b_n$ is true if either $b_n$ is false or unknown. 
\end{definition}

The left-hand side of a rule $r$ is referred to as its head, denoted by $\mi{head(r)}$, while the right-hand side is its body $\mi{body(r)}$. The positive and negative parts of the body are respectively denoted as $\mi{body^+(r)}$ and $\mi{body^-(r)}$. A rule $r$ is called \emph{positive} or
\emph{Horn} if $\mi{body^-}(r)=\emptyset$.

\begin{example}
Consider $\mi{r_2}$ from Section~\ref{sec:intro}. We have that $\mi{head(r_2)}=\{livesIn(Y,Z)\}$, while $\mi{body^+(r_2)=\{isMarriedTo(X,Y), livesIn(X,Z)\}}$, and moreover it holds that, $\mi{body^-(r_2)=\{not\;researcher(Y)\}}$. \qed
\end{example}


% such that $\vec{X}$, $Y_i$  are vectors of variables and constants with lengths $n$ and $m_i$ respectively. 
 
%$H$ is also known as the rule head and denoted as $\mi{Head(r)}$, $B$ as the positive part of the rule body $\mi{Body^+}(r)$; while, the negated part of the body ($\naf E$) is denoted as $\mi{Body^-}(r)$. 


 % For a program $P$ to be a \textit{Horn logic program}, every $r \in P$ should be \emph{positive} or \emph{Horn}. 
  
  


%Nonmonotonic logical programs are used under the answer set semantics to derive stable models over the given factual knowledge and rules. While, the answer set semantics for nonmonotonic logic programs is based on the CWA, \ie whatever can not be derived from a program is assumed to be false; Nonmonotonic logic programs are widely applied for formalizing common sense reasoning from incomplete information.
%\gad{I commented out the details of answer set semantics (\ie grounding and more)}

A logic program $P$ is \emph{ground} if it consists of only ground rules, i.e. rules without
variables. 

\begin{example}
For instance, a possible grounding of the rule $\mi{r_2}$ is given as follows $\mi{livesIn(dave,chicago)\leftarrow livesIn(clara,chicago),isMarriedTo(clara,dave),}$\\$
\phantom{livesIn(dave,chicago)\leftarrow}\naf\mi{\;researcher(dave)}$. \qed
\end{example}

Ground instantiation $Gr(P)$ of a nonground program $P$ is obtained by substituting variables with constants in all possible ways. 


\begin{definition}[Herbrand Universe, Base, Interpretation]
A \emph{Herbrand universe}  $\mi{HU(P)}$ is a set of all constants occurring in the given program $\mi{P}$. A \emph{Herbrand base}  $\mi{HB(P)}$ is a set of all possible ground atoms that can be formed with predicates and constants appearing inam $P$. A \emph{Herbrand interpretation} is any subset of $\mi{HB(P)}$.
\end{definition}

 By $\mi{MM(P)}$ we denote the set-inclusion minimal Herbrand interpretation of a ground positive program $P$.
\begin{definition}[Gelfond-Lifschitz reduct, answer set]
An interpretation $I$ of $P$ is an \emph{answer set} (or \emph{stable model}) of $P$ iff $I \in \mi{MM}(P^I)$, where $P^I$ is the \emph{Gelfond-Lifschitz (GL) reduct} of $P$, obtained from $Gr(P)$ by removing (i) each rule $r$ such that $\mi{Body}^-(r) \cap I\neq\emptyset$, and (ii) all the negative atoms from the remaining rules. The set of answer sets of a program $P$ is denoted by $AS(P)$.
\end{definition}
%
% \begin{example}
% Consider the program \\
% {\small \leftline{$P = \left\{
%             \renewcommand{\arraystretch}{1.1}
%             \begin{array}{@{\,}l@{~~}l@{}}
%               \mbox{(1) }\mi{bornInUS(alex)};\;\mbox{(2) }\mi{bornInUS(mat)};\;\mbox{(3) }\mi{immigrant(mat)};\\
%               \mbox{(4) } \mi{livesInUS(X)}\leftarrow \mi{bornInUS(X)},  \naf\ \mi{immigrant(X)}\\
%             \end{array}%
%             \!\right\}$}}
            
% \normalsize
% {\smallskip

% \noindent            
% The ground instantiation $Gr(P)$ of $P$ is obtained by substituting $X$ with $\mi{mat}$ and ${alex}$. For $I{=}\{${\small$\mi{bornInUS(alex){,}bornInUS(mat){,}immigrant(mat){,}livesInUS(alex)}$}$\}$, the GL-reduct $P^I$ of $P$ contains the rule $\mi{livesInUS(alex)\leftarrow bornInUS(alex)}$ and the facts (1)-(3). As $I$ is a minimal model of $P^I$, it  is an answer set of $P$.}\qed
% \end{example}
\begin{example}\label{ex:as}
Consider the program \\
{\small \leftline{$P = \left\{
            \renewcommand{\arraystretch}{1.1}
            \begin{array}{@{\,}l@{~~}l@{}}
              \mbox{(1) }\mi{livesIn(brad,berlin)};\;\mbox{(2) }\mi{isMarriedTo(brad,ann)};\\
              \mbox{(3) } \mi{livesIn(Y,Z)\leftarrow isMarriedTo(X,Y),livesIn(X,Z),  \naf\ researcher(Y)}\\
            \end{array}%
            \!\right\}$}}
            
\normalsize
{\smallskip

\noindent            
The ground instantiation $Gr(P)$ of $P$ is obtained by substituting $X,Y,Z$ with $\mi{brad, \,ann}$ and $\mi{berlin}$ respectively. For $I{=}\{${\small$\mi{isMarriedTo(brad{,}ann){,}livesIn(ann{,}berlin)},\\ \mi{livesIn(brad,berlin)}$}$\}$, the GL-reduct $P^I$ of $P$ contains $\mi{livesIn(ann,berlin)}\leftarrow \mi{livesIn(brad,berlin),isMarriedTo(brad,ann)}$ and the facts (1), (2). As $I$ is a minimal model of $P^I$, it holds that $I$ is an answer set of $P$.}\qed
\end{example}
\normalsize

The answer set semantics for nonmonotonic logic programs is based on the CWA, under which whatever can not be derived from a program is assumed to be false. Nonmonotonic logic programs are widely applied for formalizing common sense reasoning over incomplete information.
\subsection{Association Rules}
%\leanparagraph{ mining} 
An association rule is a rule where certain properties of the data in the body of
the rule are related to other properties in its head. For an example of an association rule, consider a
database containing transactional data from a store selling computer equipment.
From this data the association rule stating that 70\% of the customers
buying a laptop also buy a docking station. The knowledge that such rule reflects 
can assist in planning store layout or to decide which customers are likely to respond to an
offer.

Traditionally, the discovery of association rules  has been performed on data stored in a single table.
Recently, however, many methods for mining relational, i.e., graph-based data have been
proposed (see Section~\ref{sec:rules_kg_completion} for details). 

The notion of multirelational association rules is heavily based on frequent conjunctive queries and query subsumption \cite{warmer}. 

\begin{definition}[Conjunctive Query]
A \emph{conjunctive query} $Q$ over a knowledge graph $\cG$ is of the form $Q(\vec{X}):-p_1(\vec{X1}),\dotsc,p_m(\vec{X_m})$. Its  right-hand side (i.e., body) is a finite set of possibly negated atomic formulas over $\cG$, while the left-hand side (i.e., head) is a tuple of variables occurring in the body. The \emph{answer} of $Q$ on $\cG$ is the set $Q(\cG):=\{f(\vec{Y})\,|\,\vec{Y}\,\text{  is the head of } Q \text{ and } f \text{ is a matching of } Q \text{ on } \cG\}$.
\end{definition}

Following \cite{DBLP:conf/ilp/DehaspeR97}, the \emph{(absolute) support} of a conjunctive query $Q$ in a KG $\cG$ is the number of distinct tuples in the answer of $Q$ on $\cG$. 

\begin{example}
The support of the query
\begin{equation}\mi{Q(X,Y,Z):-marriedTo(X,Y),\, }\mi{livesIn(X,Z)}
\end{equation}
over $\cG$ in Figure~\ref{rdf} asking for people, their spouses and living places is $6$.
\end{example} 
Formally, an \emph{association rule} is of the form $Q_1 => Q_2$, such that $Q_1$ and $Q_2$ are both conjunctive queries and the body of $Q_1$ considered as a set of atoms is included in the body of $Q_2$,  i.e., $Q_1(\cG')\subseteq Q_2(\cG')$ for any possible KG $\cG'$. 

For example, from the above $Q(X,Y,Z)$ and
\begin{equation}Q'(X,Y,Z):-\mi{marriedTo(X,Y),\,livesIn(X,Z),\,} \mi{livesIn(Y,Z)}
\end{equation} we can construct the rule $Q => Q'$. 
 

Association rules are sometimes exploited for reasoning purposes, and thus (with some abuse of notation) can be treated as logical rules, i.e., for $Q_1=>Q_2$ we write $Q_2\backslash Q_1 \leftarrow Q_1$, where $Q_2 \backslash Q_1$ refers to the set difference between $Q_2$ and $Q_1$ considered as sets. For example, $Q=>Q'$ from above corresponds to $\mi{r1}$ from Section~\ref{sec:intro}.

A large number of various measures for evaluating the quality of association rules and their subsequent ranking have been proposed, e.g., \emph{support, confidence}. % The latter is accepted to be appropriate for estimating the actual implication of the rule at hand, and is thus particularly attractive for predictive purposes.
For $r:\;\mi{H\leftarrow B, \naf\ E}$, with $H=\mi{h(X,Y)}$ and $B,E$ involving variables from $\vec{Z}\supseteq X,Y$ and a KG $\cG$, the \emph{standard confidence} (or \textit{confidence}) is given by:
\vspace{-.26cm}
\begin{align*}
conf(r,\cG)= \frac{\textit{r-supp}(r,\cG)}{\textit{b-supp}(r,\cG)}
\end{align*}
where $\textit{r-supp}(r,\cG)$ and $\textit{b-supp}(r ,\cG)$ are the \textit{rule support} and \textit{body support}, respectively, which are defined as follows:
\begin{align*}
\textit{r-supp}(r,\cG) &= \#(X,Y): H \in \cG, \exists \vec{Z}\;B\in \cG,E \not \in \cG\\
\textit{b-supp}(r,\cG) &= \#(X,Y):\exists \vec{Z}\; B\in \cG, E \not \in \cG
\end{align*}
\begin{example}
Consider the example rules $\mi{r_1}$, $\mi{r_2}$, and the KG $\cG$ in Figure \ref{rdf}, we have $\textit{r-supp}(r_1,\cG) = \textit{r-supp}(r_2,\cG) = 3$, $\textit{b-supp}(r_1,\cG) = 6$ and $\textit{b-supp}(r_2,\cG) = 4$.
Hence, $\mi{conf(r_1,\cG) = \frac{3}{6}}$ and $\mi{conf(r_2,\cG) = \frac{3}{4}}$.\qed
\end{example}
%\begin{equation}
%\mi{conv(r, \cG)= \dfrac{1 - supp(h(X,Y), \cG)}{1 - conf(r, \cG)}}
%\end{equation}
%where $\mi{supp(h(X,Y),\cG)}$ is the \textit{relative support} of $\mi{h(X,Y)}$ defined as follows:
%\vspace{-.28cm}
%\begin{equation}
%supp(h(X,Y),\cG)=\dfrac{\#(X,Y):h(X,Y)\in \cG}{(\#X:\exists Y\;h(X,Y)\in \cG)*(\#Y:\exists X\;h(X,Y)\in \cG)}
%\end{equation}
%and $\mi{conf}$ is the confidence of $r$ given as
%\begin{equation}
%\mi{conf(r,\cG)=\dfrac{\#(X,Y): H \in \cG, \exists \vec{Z}\;B\in \cG,E \not \in \cG}{\#(X,Y):\exists \vec{Z}\; B\in \cG, E \not \in \cG}}
%\end{equation}
%\vspace{-.3cm}
%\begin{example}
%The conviction of the above rule $\mi{r1}$ is $\mi{conv(r1,\cG)}=\dfrac{1-0.3}{1-0.5}=1.4$\qed
%\end{example}

% \subsection{Rule-based Reasoning tasks over KGs} Logical programs are used for KGs refinement. It has two main tasks that solves the shortcomings of existing KGs, namely, inaccuracy and incompleteness, through \textit{KG cleaning} and \textit{KG completion} tasks respectively.

% \leanparagraph{KG cleaning}

% \leanparagraph{KG completion} In this task rules are used to predict the missing facts in the KG based on the existing facts in the knowledge graph. This can be formally defined as:

% \begin{definition}[Rule-based KG completion]\label{def:graphcompl}
% Let $\cG$ be a KG and $\cA$ its factual representation over the signature $\Sigma_{\cA}=\tuple{\mathbf{C},\mathbf{R},\cC}$. Let, moreover, $\cR$ be a set of rules %mined from $\cG$,
%  i.e. rules over the signature $\Sigma_{\cR}=\tuple{\mathbf{C}\cup \mathbf{R},\cC}$. % mined from $\cG$.
% Then \emph{completion of $\cG$ (resp. $\cA$) \wrt\ $\cR$} is a graph $\cG_{\cR}$ constructed from any answer set $\cA_{\cR}\in AS(\cR \cup \cA)$. 
% \end{definition}

